sdi1900085 Δημόκριτος Κολίτσος

Αρχεία: poller.cpp, pollSwayer.cpp
Compilation:server: make poller
            client: make pollSwayer
Εκτέλεση:   server: ./poller 5005 10 5 log.txt stat.txt
            client: ./pollSwayer 127.0.0.1 5005 inputFile

documentation: για περισσότερες (η και λιγότερες απο θέμα ποσότητας γραπτού) λεπτομέριες υπάρχουν αναλυτικά comments
στον κώδικα

poller:

-Υλοποίηση του server γενικά:
Αρχικά καθώς θα γίνει χρήση pthread της c στων οποίων τις συναρτήσεις δεν είναι εύκολο να σταλούν πολλά ορίσματα,
υπάρχουν global μεταβλητές οι οποίες αρχικοποιούνται στη main και χρησιμοποιούνται από διαφορετικά threads. Τα
client sockets θα αποθηκεύονται σε ένα queue (connectionBuffer), τα worker threads σε ένα vector (workerThreads)
και για την αποθήκευση των δεδομένων της ψηφοφορίας γίνεται χρήση unordered map (δεν μας ενδιαφέρει ιδιαίτερα η
σειρά οπότε είναι πιο efficient απο map) στα οποία συσχετίζονται οι ψηφοφόροι με το κόμμα που ψήφισαν και τα κόμματα
με τον αριθμό ψήφων που έλαβαν.
Στη main το πρόγραμμα ξεκινάει με τον έλεγχο του αριθμού των args. Εφόσον έχει δοθεί ο σωστός αριθμός args η main
προχωράει στην αντιστοίχησή τους με τις κατάληλες μεταβλητές: 1ο argument το port στο οποίο θα ακούει το σέρβερ, 2o
o αριθμός των worker threads, 3ο το μέγεθος του buffer και τέλος τα ονόματα των αρχείων στα οποία θα αποθηκευτούν οι
πληροφορίες και τα αποτελέσματα της ψηφοφορίας. Ακολουθεί το άνοιγμα του σερβερ δημιουργόντας το socket που θα έχει
IPv4 διεύθυνση και TCP πρωτόκολλο επικοινωνίας για αξιόπιστη μεταφορά δεδομένων. Μετά το σετάρισμα της διεύθυνσης του
σερβερ το socket γίνεται bound με αυτή και το port που δόθηκε απ το χρήστη και το σέρβερ ξεκινά να ακούει στο socket
εκτυπόνοντας "Server started." στο terminal. Έπειτα θα γίνει προληπτική εκαθάριση του log αρχείου που, σε παρίπτωση
που έχει ξανατρέξει το σέρβερ προηγουμένος, θα περιέχει στοιχεία που πιθανός να επηρεάσουν την αποθήκευση καινούριων
πληροφοριών (ήδη υπάρχοντα ονόματα θα κάνουν register ως already vored). Μετά την ολοκλήρωση των παραπάνω είμαστε έτοιμοι
να δημιουργήσουμε το master thread.

-Master Thread(δημιουργια threads):
To Master thread δημιουργείται στη main και παίρνει ως όρισμα τον αριθμό των worker threads που θα πρέπει να δημιουργήσει.
Στο master thread, αφού καταχωρήσουμε το signal handler για το σήμα SIGINT (για να μπορεί το πρόγραμμα να αναγνωρίσει το
σήμα εάν ο χρήστης πατήσει ctrl+C), ξεκινάμε την δημιουργεία των worker threads. Εφόσον είμαστε αναγκασμένοι απ τη δομή
της βιβλιοθήκης pthread, η συνάρτηση masterThreadFunc έχει πάρει τον integer αριθμό των worker threads που πρέπει να
φτιάξει ως void* οπότε πρέπει να τον κάνουμε convert πίσω σε integer πριν μπορούμε να τον χρησιμοποιήσουμε για τη
δημιουργία των worker threads. Αφού δημιουργήσουμε τα worker threads, τα αποθηκεύουμε στο workerThreads vector για να
έχουμε τη δυνατότητα πρόσβασης στο καθένα (στον τερματισμό του σερβερ θα πρέπει πρώτα να τερματιστούν τα worker threads).
Το master thread δημιουργεί ένα επιπλέον thread το οποίο είναι υπεύθυνο για την αποδοχή connections στο server. 

-acceptConnections:
Το acceptConnections thread κάνει accept αιτήματα σύνδεσης στον σερβερ. Αφού δεχτεί κάποιο έτοιμα επιτυχώς κλειδώνει το
bufferMutex mutex (το οποίο έχει σκοπό να κρατάει την πρόσβαση στον buffer exclusive έτσι ώστε να γίνεται σωστή αποθήκευση
και πρόσβαση των περιεχομένων του), το mutex καθώς και τα συσχετισμένα condition variables bufferEmpty και bufferFull είναι
της βιβλιοθήκης pthread η οποία δεν δημιρουργεί κάποιο object που θα χρειαστεί να γίνει destruct στον τερματισμό του thread
καθώς είναι πολύ πιθανό το acceptConnections και τα workerThreads να γίνουν cancel. Έπειτα το thread θα περιμένει μέχρι να
υπάρξει διαθέσιμος χώρος στo buffer. Η συνάρτηση pthread_cond_wait χρησιμοποιείται για την αναμονή στo condition variable
bufferFull, το οποίο σχετίζεται με το bufferMutex. Το bufferMutex απελευθερώνεται μέχρι η συνθήκη που ελένχει εάν το size
του buffer είναι μικρότερο απ το size που έχει θέσει ο χρήστης (όταν θα γίνει notify το cv θα γίνει ξανά έλενχος απ τη while).
Όταν η συνάρτηση γίνει notified και υπάρχει χώρος στο buffer το mutex ξανακλειδώνει, αποθηκεύουμε στον buffer το socket του
client και ενημερώνουμε ένα (worker) thread που περιμένει στο bufferEmpty condition variable (που περιμένει δηλαδή να υπάρξει
κάποια σύνδεση) και τελικά απελευθερόεται για άλλη μια φορά το mutex. Αυτό συνεχίζει να γίνεται μέχρι το σερβερ να λάβει το
SIGINT signal.

-Worker Threads:
To κάθε worker thread με τη σειρά του κλειδώνει τον bufferMutex, περιμένει με αντίστοιχο τρόπο όπως η accept στο bufferEmpty
condition variable μέχρι το buffer να μην είναι άδειο, λαμβάνει το socket του client απ το buffer και το αφαιρεί απ αυτό
εφόσον θα το εξυπηρετήσει. Τέλος αφού απελευθερώθηκε χώρος στο buffer ενημερώνεται η accept connections που ίσως περιμένει
στο bufferFull condition variable για να ενημερώσει το buffer με νέα σύνδεση. Αφού απελευθερωθεί και το bufferMutex γίνεται
κλήση της handleConnection δίνοντάς της το συγκεκριμένο client socket. Το worker thread επαναλμβάνει τα παραπάνω μέχρι να
λάβει το σερβερ το SIGINT signal.

-handleConnection:
Η handle connection συνάρτηση εξυπηρετεί τα αιτήματα των clients με socket το clientSocket. Αρχηκά στέλνει μήνυμα στον client
να στείλει το όνομα του ψηφοφόρου. Με την recv παίρνει απάντηση απ τον client και ελένχει εάν το όνομα υπάρχει ήδη στο log.txt
με την hasVoted, κάτι το οποίο μας δείχνει ότι ο συγκεκριμένος ψηφοφόρος έχει ήδη ψηφίσει οπότε και δεν θα καταμετριθεί νέα
ψήφος. Εάν δεν έχει ψηφίσει ήδη ο ψηφοφόρος ο client θα στείλει και το κόμμα το οποίο ψηφίστηκε. Αφού έχουμε τα 2 string που
χρειαζόμαστε κλειδόνουμε το mutex που αντιστοιχεί στην πρόσβαση στο log.txt και ανοίγουμε το αρχείο σε append mode για να μην
χαθούν οι προηγούμενες καταγραφές. Έπειτα γράφουμε το όνομα και την ψήφο που στάλθηκαν μέσα στο log.txt, το κλείνουμε και
ελευθερόνουμε και το mutex. Στη συνέχεια κλειδόνουμε τον pollDataMutex για να ενημερώσουμε τα pollData και pollStats αρχεία
αποθηκεύοντας το όνομα και την ψήφο καθός και ενημερόνοντας τα κόμματα και τον αρθιμό των ψήφων του καθενός αντίστοιχα. Τέλος
αφού ξεκλειδόσουμε το pollDataMutex στέλνουμε επιβεβαιοτικό μήνυμα στον client και κλείνουμε την σύνδεση.

-handleSignal, SIGNINT και master thread:
Το σέρβερ έχει την δυνατότητα να αναγνωρίσει SIGINT σημα που μπορεί να δοθεί απ τον χρήστη. Γίνεται η χρήση atomic μεταβλητής
τύπου booleanγια τον έλεγχο εάν έχει δοθεί το σήμα καθώς έχει καθορισμένη συμπεριφορά σε περίπτωση που παραπάνω από ένα thread
ελένχει ή/και αλλάζει την μεταβλητή. H handleSignal είναι υπέυθυνη για την αναγνώριση του σήματος και την ενημέρωση της
μεταβλητής σε true. Καθώς μετά την δημιουργία των υπόλοιπων thread το master thread απλά περιμένει, έχει επίσης δημιουργηθεί
ειδικό mutex και condition variable για την αποφυγή busy waiting απ το master thread. Όταν η handleSignal λάβει το SIGINT
αφού ενημερώσει την terminateSignal, αμέσως ενημερώνει το master thread που ήταν σε κατάσταση wait. Αφού ενημερωθεί το master
thread αυτό με τη σειρά του τερματίζει όσα υπόλοιπα threads δεν έχουν τερματιστεί από μόνα τους, καλεί την writePollResults
συνάρτηση και επιστρέφει στη main για να κλείσει το server.

-writePollResults και κλείσιμο του σερβερ:
Πριν τερματίσει το master thread αφού λάβει το SIGINT σήμα κρατάει τα αποτελέσματα που έχει καταμετρήσει για την ψηφοφορία στο
pollStats αρχείο. Κλειδώνει το pollDataMutex καθώς θα προσπελάσει το pollStats map και έπειτα ανοίγει το pollStats αρχείο σε
write mode (υπάρχον περιεχόμενα απο τυχόν προιγούμενες εκτελέσεις θα γίνουν overwrite). Έπειτα θα προσπελάσει το map γράφοντας
στο αρχείο το κάθε κόμμα και τον αριθμό των ψήφων που μάζεψε καθώς και κρατάει τον συνολικό αριθμό τον ψήφων που έγιναν τον
οποίο και καταγράφει στο τέλος του αρχείου. Τέλος το πρόγραμμα επιστρέφει στη main όπου και κάνει shutdown κάθε connection του
σερβερ για να εξασφαλίσει να μην υπάρξει απώλεια δεδομένων που τυχόν ήταν σε κατάσταση μεταφοράς και έπειτα το κλείνει 
εμφανίζοντας αντίστοιχο ενημερωτικό μήνυμα στον χρήστη.

pollSwayer:

-main:
Αρχικά γίνεται έλεγχος του αριθμού των arguments. Μετά αποθηκεύονται το όνομα του σέρβερ, το port στο οποίο ακούει και το όνομα
του input αρχείου το οποίο περιέχει τα δεδομένα της ψηφοφορίας. Έπειτα ανοίγουμε το αρχείο με σκοπό να διαβάσουμε απ αυτό μια
μια κάθε γραμμή του και για κάθε μια εφόσον ακολουθεί το σωστό φόρματ (ονομα επώνυμο κόμμα) δημιουργούμε ένα thread το οποίο με
τη σειρά του εκτελεί την handleConnection συνάρτηση που ασχολείται με την σύνδεση και την επικοινωνία με το σερβερ. Στον client
αντί για την pthread της c χρησιμοποιούμε την βιβλιοθήκη thread της c++ καθώς δεν θα χρειαστεί να κάνουμε cancel κάποιο thread
και προσφέρουν δυνατότητες όπως εύκολο πέρασμα ορισμάτων στις συναρτήσης των thread. H main κρατάει track των threads αποθηκέυοντάς
τα σ ένα vector το οποίο και χρησιμοποιεί για να τα περιμένει να τερματίσουν. αφού τερματίσουν όλα κλέινει το αρχείο και τερματίζει.

-handleConnection:
Το κάθε thread με τη σειρά του μέσα στην handleConnection σετάρει το client socket, την διεύθυνση του και κάνει αίτηση στο σερβερ
να συνδεθεί. Αφού η αίτηση γίνει αποδεχτή από το σερβερ δέχετε και εμφανίζει το πρώτο μήνυμα του σερβερ, μετά ενώνει το όνομα και
το επώνυμο σε ένα string και τα στέλνει στο σερβερ. Έπειτα θα ληφθεί το επόμενο μήνυμα απ το σερβερ, σ αυτό το σημείο εάν το σερβερ
επιστρέψει ότι ο ψηφοφόρος έχει ήδη ψηφίσει, από την πλευρά του σερβερ η σύνδεση θα τερματιστεί οπότε οι υπόλοιπες εντολές δεν έχουν
ιδιαίτερο νόημα. Στην περίπτωση όμως που ο ψηφοφόρος δεν έχει ξαναψηφίσει τότε θα σταλεί στο σερβερ και το όνομα του κόμματος που
ψηφήστηκε. Τέλος θα ληφθεί το τελευταίο μήνυμα απ το σερβερ και η συγκεκριμένη σύνδεση θα τερματιστεί.